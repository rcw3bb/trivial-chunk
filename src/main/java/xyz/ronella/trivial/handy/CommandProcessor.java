package xyz.ronella.trivial.handy;

import xyz.ronella.trivial.decorator.StringBuilderAppender;
import xyz.ronella.trivial.functional.NoOperation;

import java.io.IOException;
import java.io.InputStream;
import java.util.Optional;
import java.util.Scanner;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * A utility class for running executable commands.
 *
 * @author Ron Webb
 * @since 2.18.0
 */
final public class CommandProcessor {

    private CommandProcessor() {}

    private static <T_OUTPUT> Optional<T_OUTPUT> internalProcess(final Supplier<ProcessBuilder> genProcessBuilder,
                                                        final Consumer<Process> initProcess,
                                                        final Function<Process, T_OUTPUT> outputLogic,
                                                        final ICommandArray command) {

        return Optional.ofNullable(command).map(___command -> {

            final var builder = Optional.of(genProcessBuilder.get()).orElse(new ProcessBuilder());
            builder.command(___command.getCommand());

            final Process process;

            try {
                process = builder.start();
            } catch (IOException ioe) {
                throw new CommandProcessorException(ioe);
            }

            initProcess.accept(process);

            return outputLogic.apply(process);
        });
    }

    /**
     * Process a command.
     * @param genProcessBuilder Logic that creates an instance of ProcessBuilder.
     * @param command An implementation of ICommandArray.
     * @return The optional output of the processed command.
     */
    public static Optional<Integer> process(final Supplier<ProcessBuilder> genProcessBuilder,
                                     final ICommandArray command) {

        return internalProcess(genProcessBuilder, NoOperation.consumer(), ProcessOutputHandler.defaultOutputHandler(),
                command);
    }

    /**
     * Process a command.
     * @param genProcessBuilder Logic that creates an instance of ProcessBuilder.
     * @param initProcess Logic to initialize the process.
     * @param outputLogic Logic to handle the output of the process.
     * @param command An implementation of ICommandArray.
     * @return The optional output of the processed command.
     * @param <T_OUTPUT> The type of the output generated by the output logic.
     */
    public static <T_OUTPUT> Optional<T_OUTPUT> process(final Supplier<ProcessBuilder> genProcessBuilder,
                                                        final Consumer<Process> initProcess,
                                                        final Function<Process, T_OUTPUT> outputLogic,
                                                        final ICommandArray command) {

        return internalProcess(genProcessBuilder, initProcess, outputLogic, command);
    }

    /**
     * Process a command.
     * @param genProcessBuilder Logic that creates an instance of ProcessBuilder.
     * @param initProcess Logic to initialize the process.
     * @param command An implementation of ICommandArray.
     * @return The optional output of the processed command.
     */
    public static Optional<Integer> process(final Supplier<ProcessBuilder> genProcessBuilder,
                                                        final Consumer<Process> initProcess,
                                                        final ICommandArray command) {

        return internalProcess(genProcessBuilder, initProcess, ProcessOutputHandler.defaultOutputHandler(), command);
    }


    /**
     * Process a command.
     * @param initProcess Logic to initialize the process.
     * @param outputLogic Logic to handle the output of the process.
     * @param command An implementation of ICommandArray.
     * @return The optional output of the processed command.
     * @param <T_OUTPUT> The type of the output generated by the output logic.
     */
    public static <T_OUTPUT> Optional<T_OUTPUT> process(final Consumer<Process> initProcess,
                                                        final Function<Process, T_OUTPUT> outputLogic,
                                                        final ICommandArray command) {

        return internalProcess(ProcessBuilder::new, initProcess, outputLogic, command);
    }

    /**
     * Process a command.
     * @param initProcess Logic to initialize the process.
     * @param command An implementation of ICommandArray.
     * @return The optional output of the processed command.
     */
    public static Optional<Integer> process(final Consumer<Process> initProcess, final ICommandArray command) {

        return internalProcess(ProcessBuilder::new, initProcess, ProcessOutputHandler.defaultOutputHandler(), command);
    }

    /**
     * Process a command.
     * @param genProcessBuilder Logic that creates an instance of ProcessBuilder.
     * @param outputLogic Logic to handle the output of the process.
     * @param command An implementation of ICommandArray.
     * @return The optional output of the processed command.
     * @param <T_OUTPUT> The type of the output generated by the output logic.
     */
    public static <T_OUTPUT> Optional<T_OUTPUT> process(final Supplier<ProcessBuilder> genProcessBuilder,
                                 final Function<Process, T_OUTPUT> outputLogic, final ICommandArray command) {

        return internalProcess(genProcessBuilder, NoOperation.consumer(), outputLogic, command);
    }

    /**
     * Process a command.
     * @param outputLogic Logic to handle the output of the process.
     * @param command An implementation of ICommandArray.
     * @return The optional output of the processed command.
     * @param <T_OUTPUT> The type of the output generated by the output logic.
     */
    public static <T_OUTPUT> Optional<T_OUTPUT> process(final Function<Process, T_OUTPUT> outputLogic,
                                                        final ICommandArray command) {

        return internalProcess(ProcessBuilder::new, NoOperation.consumer(), outputLogic, command);
    }

    /**
     * Process a command.
     * @param command An implementation of ICommandArray.
     * @return The exit code of the command.
     */
    public static Optional<Integer> process(final ICommandArray command) {
        return internalProcess(ProcessBuilder::new, NoOperation.consumer(), ProcessOutputHandler.defaultOutputHandler(), command);
    }

    /**
     * The class that holds some implementations of output handler.
     */
    public static final class ProcessOutputHandler {

        private ProcessOutputHandler() {}

        /**
         * Capture the output of the command to the default output and error stream.
         * @return The exit code of the command.
         */
        public static Function<Process, Integer> defaultOutputHandler() {
            return captureStreams((___output, ___error) -> {
                final var outputScanner = new Scanner(___output);
                final var errorScanner = new Scanner(___error);

                while (outputScanner.hasNextLine()) {
                    System.out.println(outputScanner.nextLine());
                }

                while (errorScanner.hasNextLine()) {
                    System.err.println(errorScanner.nextLine());
                }
            });
        }

        private static String streamToString(final InputStream inputStream) {
            final var outputScanner = new Scanner(inputStream);
            final var delim = "\n";
            final var sbOutput = new StringBuilderAppender(___sb -> ___sb.append(!___sb.isEmpty() ? delim : ""));
            outputScanner.useDelimiter(delim);

            while (outputScanner.hasNextLine()) {
                sbOutput.append(outputScanner.nextLine());
            }

            return sbOutput.toString();
        }

        /**
         * Capture the output as string.
         * @return The output string.
         */
        public static Function<Process, String> outputToString() {
            return (___process) -> {
                try (var output = ___process.getInputStream()) {
                    return streamToString(output);
                } catch (IOException ioe) {
                    throw new CommandProcessorException(ioe);
                }
            };
        }

        /**
         * Capture the error as string.
         * @return The error string.
         */
        public static Function<Process, String> errorToString() {
            return (___process) -> {
                try (var error = ___process.getErrorStream()) {
                    return streamToString(error);
                } catch (IOException e) {
                    throw new CommandProcessorException(e);
                }
            };
        }

        /**
         * Process the output and error streams manually.
         * @param streams The logic process the streams.
         * @return The exit code of the command.
         */
        public static Function<Process, Integer> captureStreams(BiConsumer<InputStream, InputStream> streams) {
            return (___process) -> {
                try (var output = ___process.getInputStream();
                     var error = ___process.getErrorStream()) {

                    streams.accept(output, error);

                    return ___process.exitValue();
                } catch (IOException ioe) {
                    throw new CommandProcessorException(ioe);
                }
            };
        }

        /**
         * Process the String outputs (i.e. output and error strings) manually.
         * @param outputs The logic process the output strings.
         * @return The exit code of the command.
         */
        public static Function<Process, Integer> captureOutputs(BiConsumer<String, String> outputs) {
            return captureStreams((___output, ___error) ->
                    outputs.accept(streamToString(___output), streamToString(___error)));
        }
    }

}
